# see: https://github.com/bazelbuild/rules_cc/blob/main/examples/my_c_compile/my_c_compile.bzl
# see also: https://fossies.org/linux/envoy/bazel/pch.bzl for deps usage - how to get include dirs for deps

load("@bazel_tools//tools/cpp:toolchain_utils.bzl", "find_cpp_toolchain")
load("@rules_cc//cc:action_names.bzl", "CPP_COMPILE_ACTION_NAME")

def _make_includes_rel_to_rundir(ctx, command_line):
    # Bazel cc_* rules generate info assuming a compile runs from the workspace root, ex:
    # /home/<you>/.cache/bazel/_bazel_<you>/<sha256_of_workspace_folder>/execroot/__main__
    # Running any Bazel command with -s shows it invokes actions by first cd'ing into this dir

    # Any required headers for a compile action are symlinked into the execroot tree under the current bin_dir, so, ex:
    # /home/<you>/.cache/bazel/_bazel_<you>/<sha256_of_workspace_folder>/execroot/__main__/bazel-out/k8-fastbuild/bin
    #
    # So, all include paths generated by the cc_* rules start with bazel-out/k8-fastbuild/bin/ (or whatever target/arch)
    # The rest of the include path then matches the paths of the headers in the workspace folder - say "lib/static_test"
    #
    # Side-note - for cc_library's that specify include_prefix, includes go under, say "lib/static_test/_virtual_includes/<include_prefix>/

    # But, at test binary run, the test runs from the runfiles root
    # More info: https://bazel.build/rules/rules#runfiles_location
    # Ex, bazel will start a test binary by cd'ing into the runfiles root for that binary, and will also run that binary in a sandbox (namespace/container), ex:
    #  /home/dev/.cache/bazel/_bazel_dev/<sha256_of_workspace_folder>/sandbox/processwrapper-sandbox/95/execroot/__main__/bazel-out/k8-fastbuild/bin/sample/test.sh.runfiles/__main__
    # As long as any needed headers are added to the runfiles for the test binary, they will be symlink'd/copied into the runfiles tree, but at their short paths, so, again for ex
    #  lib/static_test/_virtual_includes/<include_prefi>/...

    # Long story short, everything should work by chopping the bin dir off of any include arguments, and that is provided exactly by ctx.bin_dir.path

    # This seems fragile
    # Another approach is to actually do all the test compiling at build time via ctx.run (so the action runs in the exec root and no path hacking is needed)
    # This would output a test binary that literally just dumps the results recorded from build time
    # Since actions must be predeclared in Starlark there's no way to know ahead of time how many test-compile actions to run, so there would always be only one action
    # doing all of the test compiles

    # This is less desirable as doing the compilation in the test binary can take advantage of test sharding to distribute the test compiles of the different test cases
    # across many processes or even workers in the case of remote execution

    return [arg.replace(ctx.bin_dir.path + "/", "") for arg in command_line]

def _find_cc_info(ctx, cc_source_file, cc_deps, copts):
    """Return info about how to compile a single source file and its dependencies

    cc_source_file:     The single source file being compiled
    cc_deps:            Its deps - likely just other cc_library()'s
    copts:              Any additional copts to use when compiling this test source
    """
    cc_toolchain = find_cpp_toolchain(ctx)
    source_file = ctx.file.src

    merged_cc_info_deps = cc_common.merge_cc_infos(
        cc_infos = [dep[CcInfo] for dep in cc_deps],
    )

    merged_compilation_context_deps = cc_common.merge_compilation_contexts(
        compilation_contexts = [dep[CcInfo].compilation_context for dep in cc_deps],
    )

    deps_ctx = merged_cc_info_deps.compilation_context

    feature_configuration = cc_common.configure_features(
        ctx = ctx,
        cc_toolchain = cc_toolchain,
        requested_features = ctx.features,
        unsupported_features = ["module_maps"] + ctx.disabled_features,
    )

    c_compiler_path = cc_common.get_tool_for_action(
        feature_configuration = feature_configuration,
        action_name = CPP_COMPILE_ACTION_NAME,
    )

    c_compile_variables = cc_common.create_compile_variables(
        feature_configuration = feature_configuration,
        cc_toolchain = cc_toolchain,
        user_compile_flags = ctx.fragments.cpp.copts + ctx.fragments.cpp.cxxopts + copts,
        source_file = cc_source_file.path,
        output_file = "dummy_output.o",
        include_directories = deps_ctx.includes,
        quote_include_directories = deps_ctx.quote_includes,
        system_include_directories = deps_ctx.system_includes,
        framework_include_directories = deps_ctx.framework_includes,
    )

    command_line = cc_common.get_memory_inefficient_command_line(
        feature_configuration = feature_configuration,
        action_name = CPP_COMPILE_ACTION_NAME,
        variables = c_compile_variables,
    )

    env = cc_common.get_environment_variables(
        feature_configuration = feature_configuration,
        action_name = CPP_COMPILE_ACTION_NAME,
        variables = c_compile_variables,
    )

    return struct(
        compiler_path = c_compiler_path,
        command_line = _make_includes_rel_to_rundir(ctx, command_line),
        env = env,
        # Not sure if all_files is needed or if just compiler/compiler_executable could somehow be listed
        toolchain_files = cc_toolchain.all_files.to_list(),
    )

def _find_dep_headers(cc_deps):
    """Finds all public headers of all passed in deps"""

    dep_headers = []
    for dep in cc_deps:
        dep_headers.extend(dep[CcInfo].compilation_context.direct_public_headers)

    return dep_headers

def _impl_runner_cc_comp_test(ctx):
    """Impl of rule to build the test runner for testing compile time asserts

    ctx:    Rule context
    """
    source_file = ctx.file.src

    output_file = ctx.actions.declare_file(ctx.label.name + ".sh")
    test_runner = ctx.attr._test_runner
    test_runner_wrapper = ctx.file._test_runner_wrapper
    info_binary = ctx.attr.info_binary.files_to_run.executable
    test_runner = ctx.executable._test_runner
    cc_source_file = ctx.file.src
    cc_deps = ctx.attr.deps + ctx.attr._needed_libs
    copts = ctx.attr.copts

    cc_info = _find_cc_info(ctx, cc_source_file = cc_source_file, cc_deps = cc_deps, copts = copts)

    # See https://bazel.build/reference/test-encyclopedia#test-sharding
    # Can shard runs at runtime - threading
    ctx.actions.expand_template(
        template = test_runner_wrapper,
        substitutions = {
            # need to use short_path to get path relative to runfiles location - see: https://bazel.build/rules/rules#runfiles_location
            "{TEST_RUNNER}": test_runner.short_path,
            "{INFO_BINARY}": info_binary.short_path,
            "{COMPILER_PATH}": cc_info.compiler_path,
            "{SOURCE_FILE}": source_file.short_path,
            "{ARGS}": " ".join(cc_info.command_line),
        },
        output = output_file,
        is_executable = True,
    )

    dep_headers = _find_dep_headers(cc_deps = cc_deps)

    runfiles = ctx.runfiles(
        files = dep_headers + cc_info.toolchain_files + [test_runner, source_file, info_binary],
    )

    # TODO sharding: https://bazel.build/reference/test-encyclopedia#test-sharding

    return [
        DefaultInfo(
            executable = output_file,
            runfiles = runfiles,
        ),
    ]

_runner_cc_comp_test = rule(
    doc = """
    Generates the test runner to test compile time assertions

    This is not the actual rule the end-user sees, but is wrapped by the cc_comp_test() macro
    This is because a helper cc_binary "info_binary" also needs to be defined by this macro, and is used by
    this rule during test execution
    """,
    implementation = _impl_runner_cc_comp_test,
    attrs = {
        "src": attr.label(
            allow_single_file = True,
            doc = "The source file containing compile time assert test cases",
        ),
        "copts": attr.string_list(
            doc = "copts - same as for other cc_* rules",
        ),
        "deps": attr.label_list(
            providers = [CcInfo],
            doc = "Dependencies of this test - usually other cc_library()'s",
        ),
        "info_binary": attr.label(
            executable = True,
            cfg = "target",
            providers = [CcInfo],
            doc = "Info binary - this provides about the compile time test cases defined in 'src', and is used by the test runner to discover these test cases",
        ),
        "_cc_toolchain": attr.label(
            default = "@bazel_tools//tools/cpp:current_cc_toolchain",
            doc = "Implicit arg - needed to get toolchain - https://bazel.build/docs/integrating-with-rules-cc#access-c-toolchain",
        ),
        "_needed_libs": attr.label_list(
            default = ["//lib:comp_test"],
            providers = [CcInfo],
            doc = "Implicit arg - helper libraries needed to build 'src' when testing compile time test cases",
        ),
        "_test_runner": attr.label(
            default = "//test_runner:test_runner",
            executable = True,
            cfg = "target",
            providers = [CcInfo],
            doc = "Implicit arg - the actual test runner - runs the test cases in 'src', validates results, and writes junit XML.  Wrapped by '_test_runner_wrapper'",
        ),
        "_test_runner_wrapper": attr.label(
            allow_single_file = True,
            default = "test.sh.tpl",
            doc = "Implicit arg - the generated test binary Bazel will run when executing the test cases in 'src'.  Just wraps '_test_runner' - captures needed args and context for _test_runner",
        ),
    },
    toolchains = ["@bazel_tools//tools/cpp:toolchain_type"],
    fragments = ["cpp"],
    test = True,
)

def cc_comp_test(name, src = None, copts = [], deps = []):
    """Define a C++ compile time test

    Just like cc_test() but for testing compile time assertions like static_assert().

    Use this to write test cases for APIs in your library that should static_assert() under expected conditions

    Note:   This macro contains two parts
        * {name}.cc_comp_test.info_binary - a cc_binary() that outputs info about the test cases in 'src'
            * This is used by the actual test rule at test time
        * a _runner_cc_comp_test() rule that generates the actual test binary Bazel runs at test time

    Args:
        name:   Will be used for name of _runner_cc_comp_test rule
        src:    The source file containing compile time test cases.  Optional - if omitted, '{name}.cc' is used instead
        copts:  C flags - same as copts in cc_binary and other rules
        deps:   Dependencies of src - other cc_library()'s, etc.  Usually the library you are writing compile time test cases for
    """
    src = src if src else name + ".cc"

    info_binary = "{}.info".format(name)

    native.cc_binary(
        name = info_binary,
        srcs = [src],
        deps = deps + ["//lib:comp_test", "//info_binary:info_binary_main"],
    )

    _runner_cc_comp_test(
        name = name,
        src = src,
        deps = deps,
        copts = copts,
        info_binary = info_binary,
    )
